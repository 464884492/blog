##Base64编码
1、三个重要概念
----
+  三个字节由四个字节表示的过程
+  Base64码表
+  补位

2、如何用三个字节表示四个字节
----
一个字节由8位二进制组成，三个字节总共28位，28 ÷ 4 = 6 , 所以转换后有效的二进制位数为6位。计算机以8位二机制为基础，所以剩下的两位在高位填充 0 。由此引申出两个重要的概念
+  为什么是64位
+  对照表

6位二进制，$2^6$ = 64 所以只能是64,当然如果愿意浪费空间也可以是 32 16 等等。对应的这些二进制怎么表示，所以定义了一个0-63的码表,分别有 A-Za-z0-9+/ 刚好64个字符
|索引| 字符||索引| 字符||索引| 字符||索引| 字符||索引| 字符||索引| 字符|
|--:|:--|:--:|--:|:--|:--:|--:|:--|--:|:--|:--:|--:|:--|:--:|--:|:--|
|0|A||1|B||2|C||3|D||4|E||5|F
|6|G||7|H||8|I||9|J||10|K||11|L
|12|M||13|N||14|O||15|P||16|Q||17|R
|18|S||19|T||20|U||21|V||22|W||23|X
|24|Y||25|Z||26|a||27|b||28|c||29|d
|30|e||31|f||32|g||33|h||34|i||35|j
|36|k||37|l||38|m||39|n||40|o||41|p
|42|q||43|r||44|s||45|t||46|u||47|v
|48|w||49|x||50|y||51|z||52|0||53|1
|54|2||55|3||56|4||57|5||58|6||59|7
|61|8||62|9||63|+||64|/

3、手工编码
----
3.1 刚好转换成4个二进制 
---
根据规则使用三个字节转四个字节表示，现在就拿123做实例说明，通过查询ASCII表得知123的二进制分别是 0x31(0011 0001)、0x32(0011 0010)、0x33(0011 0011),根据规则得到4个6位二进制分别是 (0011 00) (01 0011) (0010 00) (11 0011),然后依次在高位补0即，右移2为，得到4个8位二进制 (**00** 0011 00) (**00** 01 0011) (**00** 0010 00) (**00** 11 0011),通过进制转换得到4个十进制数字，分别是(12)(19)(8)(51)。通过查询上边码表中对应的索引的四个 字符分别是(M)(T)(I)(z),所以 123 对应的 base64编码为MTIz
3.2 转换后还剩下4位二进制
----
以12来说，字节长度为16，根据规则转换后会剩下 4 个二进制位(0011 00) (01 0011) (0010) ,分配好以后，分别在高位补两个0  (**00** 0011 00) (**00** 01 0011) (**00** 0010 ),但最后一个字节，位数不够8位，所以在最后一个字节的末尾补上2个 0  (**00** 0011 00) (**00** 01 0011) (**00** 0010 **00**)，然后在分别转换成十进制数为(12)(19)(8)查询索引表得到字符MTI,目前字符长度不够4位，所以在最后补上1个*=*。由此12最终的base64编码为MTI= 
3.3 转换后还剩下2位二进制
----
以1来说，字节长度为8 ，根据规则转换后会剩下 2 个二进制位 (0011 00) (01),分配好以后，分别在高位补两个0 (**00** 0011 00) (**00** 01 ),但最后一个字节位数不够8位，所以在最后一个字节的末尾补上 4 个0 (**00** 0011 00) (**00** 01 **0000**),然后转换成十进制数为(M)(Q),目前长度不够4位，所以在最后补上2个*=* 由此1最终的base64编码为MQ==